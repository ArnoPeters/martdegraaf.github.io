[{"content":"Introduction For a client i wanted to test that logError was called. Consider for example this piece of code below. The catch operation was added to swallow the exception of the delete action. We want to test this behaviour, but still would like to know the logError is being called.\nThe system under test 1 2 3 4 5 6 7 8 9 10 11 12 13 public async Task Delete(long sequenceNumber) { _logger.LogInformation(\u0026#34;Deleting scheduled message with sequence number `{sequenceNumber}`.\u0026#34;, sequenceNumber); try { await _client.Delete(..); _logger.LogInformation(\u0026#34;Deleted scheduled message with sequence number `{sequenceNumber}`.\u0026#34;, sequenceNumber); } catch (InvalidOperationException ex) when (ex.Message.Equals($\u0026#34;The scheduled message with SequenceNumber = {sequenceNumber} is already being cancelled.\u0026#34;)) { _logger.LogError(ex, \u0026#34;Ignored InvalidOperationException for when the message {sequenceNumber} already has been cancelled.\u0026#34;, sequenceNumber); } } Verify that LogError is called Have you ever tried to verify your logInformation using xUnit. It does not seem to work out of the box as other FakeItEasy. I tried this code for example, but it just would not work. the throwing of exception has been left out to keep the code sample small.\n1 2 3 4 5 6 7 8 9 10 //Arrange var logger = A.Fake\u0026lt;ILogger\u0026lt;SystemUnderTest\u0026gt;\u0026gt;(); var sut = new SystemUnderTest(logger); //Act await sut.Delete(1); //Assert A.CallTo(() =\u0026gt; logger.LogError(A\u0026lt;string\u0026gt;.Ignored, A\u0026lt;object[]\u0026gt;.Ignored)) .MustHaveHappenedOnceExactly(); The LoggerExtensions class The solution was right at hand beacuse my coworker had taught this one out. With his approval i made this blog post. Use the extension as described below.\n1 2 3 4 5 6 7 8 9 10 //Arrange var logger = A.Fake\u0026lt;ILogger\u0026lt;SystemUnderTest\u0026gt;\u0026gt;(); var sut = new SystemUnderTest(logger); //Act await sut.Delete(1); //Assert logger.VerifyLogged(LogLevel.Information, \u0026#34;This log message should have been called\u0026#34;); logger.VerifyLogged(LogLevel.Error, \u0026#34;Failed to send e-mail\u0026#34;); LoggerExtensions.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 using FakeItEasy; using Microsoft.Extensions.Logging; using System; using System.Linq; using Xunit.Sdk; namespace SomeCoolNamespace; public static class LoggerExtensions { public static void VerifyLogged\u0026lt;T\u0026gt;(this ILogger\u0026lt;T\u0026gt; logger, LogLevel level, string logMessage) { var (found, actualLevel, actualMessage) = logger.VerifyLog(logMessage); if (!found) { throw new XunitException($\u0026#34;No log message found containing \u0026#39;{logMessage}\u0026#39; at any loglevel\u0026#34;); } if (actualLevel != level) { throw new AssertActualExpectedException($\u0026#34;[{level}] {logMessage}\u0026#34;, $\u0026#34;[{actualLevel}] {actualMessage}\u0026#34;, $\u0026#34;Unexpected log level for log message\u0026#34;); } } public static void VerifyNotLogged\u0026lt;T\u0026gt;(this ILogger\u0026lt;T\u0026gt; logger, LogLevel level, string logMessage) { var (found, actualLevel, actualMessage) = logger.VerifyLog(logMessage); if (found \u0026amp;\u0026amp; actualLevel == level) { throw new XunitException($\u0026#34;Log message found containing \u0026#39;{logMessage}\u0026#39; at level {level}{Environment.NewLine}Message: {actualMessage}\u0026#34;); } } public static void VerifyNotLoggedAtLevel\u0026lt;T\u0026gt;(this ILogger\u0026lt;T\u0026gt; logger, LogLevel level) { var call = Fake.GetCalls(logger) .FirstOrDefault(call =\u0026gt; (LogLevel?)call.Arguments[0] == level); if (call != null) { throw new XunitException($\u0026#34;Log message found at level {level}{Environment.NewLine}Message: {call.Arguments[2]}\u0026#34;); } } public static void VerifyLoggedAtLevel\u0026lt;T\u0026gt;(this ILogger\u0026lt;T\u0026gt; logger, LogLevel level) { var found = Fake.GetCalls(logger) .Any(call =\u0026gt; (LogLevel?)call.Arguments[0] == level); if (found) { throw new XunitException($\u0026#34;No log message found at level {level}\u0026#34;); } } private static (bool found, LogLevel? level, string? message) VerifyLog\u0026lt;T\u0026gt;(this ILogger\u0026lt;T\u0026gt; logger, string message) { var call = Fake.GetCalls(logger) .FirstOrDefault(call =\u0026gt; call.Arguments[2].ToString() .Contains(message, StringComparison.OrdinalIgnoreCase)); return (call != null, (LogLevel?)call?.Arguments[0], call?.Arguments[2].ToString()); } } Conclusion Using this class you will be able to test your logging with Xunit and FakeItEasy.\n","permalink":"https://martdegraaf.github.io/posts/verifylogged-with-xunit/","summary":"Explains how to test logInformation with Xunit.","title":"VerifyLogged with Xunit"},{"content":"This is the about me page. A very nice page indeed!\n","permalink":"https://martdegraaf.github.io/about/","summary":"This is the about me page. A very nice page indeed!","title":"About"}]