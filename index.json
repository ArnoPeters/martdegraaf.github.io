[{"content":"Introduction For a recent project, I wanted to add a property to the consumers from within my nuget package.\nFor this case i am making a Nuget package with the ID: MyProject.ExampleNuget, so replace that value for your project.\nNuget file structure MyProject.ExampleNuget (Repository level) ┣ MyProject.ExampleNuget ┃ ┣ Extensions ┃ ┃ ┗ MySpecialThing.cs ┃ ┣ MyProject.ExampleNuget.csproj ┃ ┣ MyProject.ExampleNuget.csproj.user ┃ ┗ MyProject.ExampleNuget.props ┣ AMyProject.ExampleNuget.sln ┗ nuget.config MyProject.ExampleNuget.props To enforce some property\u0026rsquo;s to the consumers of my Nuget package.\n1 2 3 4 5 6 7 8 \u0026lt;Project\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;!-- Enable output XML Docs for Swagger. --\u0026gt; \u0026lt;GenerateDocumentationFile\u0026gt;true\u0026lt;/GenerateDocumentationFile\u0026gt; \u0026lt;!-- Disable missing XML comment warnings. --\u0026gt; \u0026lt;NoWarn\u0026gt;$(NoWarn);1591\u0026lt;/NoWarn\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;/Project\u0026gt; MyProject.ExampleNuget.csproj Important is to set the build action of the MyProject.ExampleNuget.props file to package it to the build directory. See the example below:\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;None Update=\u0026#34;MyProject.ExampleNuget.props\u0026#34; Pack=\u0026#34;true\u0026#34; PackagePath=\u0026#34;build\u0026#34;\u0026gt; \u0026lt;/None\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt; References I used the following resources to fix my problem.\nhttps://stackoverflow.com/questions/67263924/create-nuget-containing-shared-project-properties-automatic-references https://learn.microsoft.com/en-us/nuget/concepts/msbuild-props-and-targets#packagereference-projects ","permalink":"https://martdegraaf.github.io/posts/add-properties-for-consuming-apps-to-a-nuget-package/","summary":"This article explains how to make a","title":"Add properties for consuming apps to a nuget package"},{"content":"Introduction For a recent project, I wanted to test that LogError was called. Consider for example this piece of code below. The catch operation was added to swallow the exception of the delete action. We want to test this behavior, but still would like to know the LogError is being called.\nThe system under test 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public async Task Delete(long sequenceNumber) { _logger.LogInformation(\u0026#34;Deleting `{sequenceNumber}`.\u0026#34;, sequenceNumber); try { await _client.Delete(..); _logger.LogInformation(\u0026#34;Delete completed `{sequenceNumber}`.\u0026#34;, sequenceNumber); } catch (InvalidOperationException ex) when (ex.Message.Equals($\u0026#34;The scheduled message with SequenceNumber = {sequenceNumber} is already being cancelled.\u0026#34;)) { _logger.LogError(ex, \u0026#34;Already cancelled {sequenceNumber}.\u0026#34;, sequenceNumber); } } Verify that LogError is called Have you ever tried to verify your LogError using xUnit? It does not seem to work out of the box as other FakeItEasy. I tried this code for example, but it just would not work. The mock that throws the exception has been left out to keep the code sample small.\n1 2 3 4 5 6 7 8 9 10 //Arrange var logger = A.Fake\u0026lt;ILogger\u0026lt;SystemUnderTest\u0026gt;\u0026gt;(); var sut = new SystemUnderTest(logger); //Act await sut.Delete(1); //Assert A.CallTo(() =\u0026gt; logger.LogError(A\u0026lt;string\u0026gt;.Ignored, A\u0026lt;object[]\u0026gt;.Ignored)) .MustHaveHappenedOnceExactly(); The LoggerExtensions class The solution was right at hand because my coworker had already figured it out. Thanks Marnix. Chekout his blog: Marnix\u0026rsquo; blog. Use the extension class as described below.\n1 2 3 4 5 6 7 8 9 10 //Arrange var logger = A.Fake\u0026lt;ILogger\u0026lt;SystemUnderTest\u0026gt;\u0026gt;(); var sut = new SystemUnderTest(logger); //Act await sut.Delete(1); //Assert logger.VerifyLogged(LogLevel.Information, \u0026#34;Deleting 1\u0026#34;); logger.VerifyLogged(LogLevel.Error, \u0026#34;Already cancelled 1\u0026#34;); LoggerExtensions.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 using FakeItEasy; using Microsoft.Extensions.Logging; using System; using System.Linq; using Xunit.Sdk; namespace SomeCoolNamespace; public static class LoggerExtensions { public static void VerifyLogged\u0026lt;T\u0026gt;(this ILogger\u0026lt;T\u0026gt; logger, LogLevel level, string logMessage) { var (found, actualLevel, actualMessage) = logger.VerifyLog(logMessage); if (!found) { throw new XunitException($\u0026#34;No log message found containing \u0026#39;{logMessage}\u0026#39; at any loglevel\u0026#34;); } if (actualLevel != level) { throw new AssertActualExpectedException( $\u0026#34;[{level}] {logMessage}\u0026#34;, $\u0026#34;[{actualLevel}] {actualMessage}\u0026#34;, $\u0026#34;Unexpected log level for log message\u0026#34;); } } public static void VerifyNotLogged\u0026lt;T\u0026gt;(this ILogger\u0026lt;T\u0026gt; logger, LogLevel level, string logMessage) { var (found, actualLevel, actualMessage) = logger.VerifyLog(logMessage); if (found \u0026amp;\u0026amp; actualLevel == level) { throw new XunitException( @$\u0026#34;Log message found containing \u0026#39;{logMessage}\u0026#39; at level {level}{Environment.NewLine}Message: {actualMessage}\u0026#34;); } } public static void VerifyNotLoggedAtLevel\u0026lt;T\u0026gt;(this ILogger\u0026lt;T\u0026gt; logger, LogLevel level) { var call = Fake.GetCalls(logger) .FirstOrDefault(call =\u0026gt; (LogLevel?)call.Arguments[0] == level); if (call != null) { throw new XunitException( @$\u0026#34;Log message found at level {level}{Environment.NewLine} Message: {call.Arguments[2]}\u0026#34;); } } public static void VerifyLoggedAtLevel\u0026lt;T\u0026gt;(this ILogger\u0026lt;T\u0026gt; logger, LogLevel level) { var found = Fake.GetCalls(logger) .Any(call =\u0026gt; (LogLevel?)call.Arguments[0] == level); if (found) { throw new XunitException($\u0026#34;No log message found at level {level}\u0026#34;); } } private static (bool found, LogLevel? level, string? message) VerifyLog\u0026lt;T\u0026gt;(this ILogger\u0026lt;T\u0026gt; logger, string message) { var call = Fake.GetCalls(logger) .FirstOrDefault(call =\u0026gt; call.Arguments[2].ToString() .Contains(message, StringComparison.OrdinalIgnoreCase)); return (call != null, (LogLevel?)call?.Arguments[0], call?.Arguments[2].ToString()); } } Conclusion Using this class you will be able to test your logging with Xunit and FakeItEasy.\n","permalink":"https://martdegraaf.github.io/posts/verifylogged-with-xunit/","summary":"Explains how to test LogError with Xunit.","title":"How to verify that ILogger actually logged an error?"},{"content":"This is the about me page. A very nice page indeed!\n","permalink":"https://martdegraaf.github.io/about/","summary":"This is the about me page. A very nice page indeed!","title":"About"}]